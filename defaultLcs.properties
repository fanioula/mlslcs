### Input filename 
filename = ../mlaslcs/datasets_not_used/mlTestbeds/mlposition4.arff

### Input testFile
testFile = ../mlaslcs/datasets_not_used/mlTestbeds/mlposition4.arff

numberOfLabels = 4

#saveRulesFile = rulesOut
#loadRulesFile = rulesOut
#testClassificationFile = outputClassification

lcsType = gr.auth.ee.lcs.implementations.MLSLCS

### When using threaded parallel LCSs
#lcsNodeType = gr.auth.ee.lcs.implementations.MLSLCS
#parallelNodes = 10

#foldsToRun = 2
#numOfFoldRepetitions = 4
### To run folds in parallel
#numOfThreads = 1

### Iteration information
trainIterations = 1500
callbackRate = 1
UpdateOnlyPercentage = .1

### Population size (micro)
populationSize = 10000

### Exploration options
gaSelection = 1
crossoverOperator = 1
crossoverRate = .8
mutationRate = .04
thetaGA = 2000
updateAlgorithmVersion = 4
gaPerLabel = false

AttributeGeneralizationRate = 0.33
LabelGeneralizationRate = 0.2

precisionBits = 5
LearningRate = 0.2

### ASLCS update options
ASLCS_Acc0 = 0.99
ASLCS_Alpha = 0.1
ASLCS_N = 10
ASLCS_ExperienceTheshold = 10
ASLCS_THETA_DEL = 10
ASLCS_DELTA = 0.1
ASLCS_OMEGA = 0.0
ASLCS_PHI = 1

### initialize the rule population by clustering
initializePopulation = true
ClusteringAttributeGeneralizationRate = 0.0
ClusteringLabelGeneralizationRate = 0.0
CLUSTER_GAMMA = 0.2


### fitness mode
### 0 for num * (acc)^n
### 1 for F + ÃŽÂ²(num * (acc)^n - F)
### 2 for fitness sharing 
FITNESS_MODE = 0

### deletion mode
### 0 for (cl.myClassifier.experience > THETA_DEL) && (data.fitness < DELTA * meanPopulationFitness)
### 1 for (cl.myClassifier.experience > THETA_DEL) && (Math.pow(data.fitness,n) < DELTA * meanPopulationFitness)
DELETION_MODE = 2

### update mode
### 0 for adding offsprings and controlling immediately
### 1 for adding all offsprings to the population and controlling once at the end of the evolution
UPDATE_MODE = 1


### check for subsumption against the population
thoroughlyCheckWIthPopulation = true

### do we allow don't cares to be a part in [C]s?
wildCardsParticipateInCorrectSets = false

### if wildCardsParticipateInCorrectSets is true, control the population of the correct sets 
### by examining the numerosity of a correct set comprising only with wildcards against that of a correct set without them 
### if [C#only] <= wildCardParticipationRatio * [C!#], the correct set consists of wildcards AND non-wildcard rules
balanceCorrectSets = false
wildCardParticipationRatio = 1

PostProcess_Experience_Theshold = 10
PostProcess_Coverage_Theshold = 0.001
PostProcess_Fitness_Theshold = 0.001

matchSetPopulationControl = false
