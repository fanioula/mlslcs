### Number of labels in the target problem.
numberOfLabels = 4

### Path to the .arff file containing the instances that the LCS will be trained with.
filename = datasets/mlposition4.arff

### Path to the .arff file  containing the instances that the LCS will be evaluated against.
### Comment out for k-fold cross-validation.
testFile = datasets/mlposition4.arff

### Number of folds for k-fold cross-validation.
#foldsToRun = 2
### Repeat each fold run <numOfFoldRepetitions> times and take into account the best result for the final evaluation metrics.
#numOfFoldRepetitions = 4
### Number of threads when running folds in parallel (in a machine with multiple processors). Each thread is assigned a fold’s run(s).
#numOfThreads = 1

### LCS implementation to be used.
lcsType = gr.auth.ee.lcs.implementations.MLSLCS

### Iteration information.
trainIterations = 1500
### Store information about the progress of the training process every <callbackRate> iterations.
callbackRate = 1
### The LCS is trained for an additional <UpdateOnlyPercentage>*<trainIterations> iterations 
### (after the initial <trainIterations> iterations) with the genetic algorithm deactivated.
UpdateOnlyPercentage = .1

### Population size (maximum number of micro-classifiers).
populationSize = 10000

### Generalization rates (per attribute/label) for covering. 
AttributeGeneralizationRate = 0.33
LabelGeneralizationRate = 0.2

### Number of bits used for representing numeric attributes.
precisionBits = 5

### Exploration options.
gaSelection = 1
### Crossover operator to be used (0: Simple single-point crossover, 1: Multi-label crossover)
crossoverOperator = 1
crossoverRate = .8
mutationRate = .04
thetaGA = 2000
updateAlgorithmVersion = 4

### Parameters for update component.
### Learning rate used to calculate the niche size estimate.
beta = 0.2
Acc0 = 0.99
N = 10
THETA_EXP = 10
THETA_DEL = 10
OMEGA = 0.9
PHI = 1.0

### Parameters for the clustering-based initialization component.
initializePopulation = true
ClusteringAttributeGeneralizationRate = 0.0
ClusteringLabelGeneralizationRate = 0.0
CLUSTER_GAMMA = 0.2

### Fitness mode.
### 0: F = num * (acc)^n
### 1: F = F + beta * (num * (acc)^n - F)
### 2: fitness sharing 
FITNESS_MODE = 0
### Learning rate for fitness sharing (only used when FITNESS_MODE = 2).
Alpha = 0.1

### Deletion mode.
### 0: (cl.exp > THETA_DEL) && (cl.fitness < DELTA * meanPopulationFitness) ? cl.cs * (meanFitness / cl.fitness) : cl.cs
### 1: (cl.exp > THETA_DEL) && (cl.fitness < DELTA * meanPopulationFitness) ? cl.cs * (meanFitness / Math.pow(cl.fitness,N)) : cl.cs
### 2: (cl.exp < THETA_DEL) ? 1 / (cl.fitness * DELTA) : 1 / (cl.fitness * Math.exp(-cl.cs + 1))
### 3: (cl.exp < THETA_DEL) ?  Math.exp(1 / cl.fitness) : Math.exp(cl.cs - 1) / cl.fitness
DELETION_MODE = 3
#DELTA = 0.1

### Update mode.
### 0: add offspring (and possibly controlling) immediately
### 1: adding all offsprings to the population and controlling once at the end of the evolution
UPDATE_MODE = 1

### Check every new classifier for subsumption against the whole population.
thoroughlyCheckWithPopulation = true

### Whether indifferent rules are allowed to be part of [C]s (and thus candidates for GA reproduction).
wildCardsParticipateInCorrectSets = false
### if wildCardsParticipateInCorrectSets is true, control the population of the correct sets 
### by examining the numerosity of a correct set comprising only with wildcards against that of a correct set without them 
### if [C#only] <= wildCardParticipationRatio * [C!#], the correct set consists of wildcards AND non-wildcard rules
balanceCorrectSets = false
wildCardParticipationRatio = 1

### Turn ‘control match set’ population control strategy on/off.
matchSetPopulationControl = false

### Path to the file where the final ruleset is to be saved.  
#saveRulesFile = rulesOut
### Path to the file from which a ruleset should be read and used to initialize the LCS.
#loadRulesFile = rulesOut

### Output file for final classification decisions for the instances in <testFile>.
#testClassificationFile = outputClassification
